<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Through the Looking-Glass</title>
  <subtitle>Mort Yao's homepage</subtitle>
  <link href="https://www.soimort.org/feed.atom" rel="self" />
  <link href="https://www.soimort.org/" />
  <id>tag:www.soimort.org,2016:/</id>
  <updated>2016-12-13T18:17:19+01:00</updated>
  <author>
    <name>Mort Yao</name>
    <email>soi@mort.ninja</email>
  </author>

  <entry>
    <title>Remember My Last Tabs, File Manager</title>
    <link href="https://www.soimort.org/notes/161208_caja" />
    <id>tag:www.soimort.org,2016:/notes/161208_caja</id>
    <updated>2016-12-13</updated>
    <author>
      <name>Mort Yao</name>
      <email>soi@mort.ninja</email>
    </author>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">

<p>It's 2016, and I can't believe that there is still no &quot;Continue where you left off&quot; option in most dominant GUI file managers (as far as I know)!</p>
<p>Yes, it bugs me when I can't restore my last open tabs and I want my old session so badly. Remembering last tabs, if I get the history right, was a feature first introduced by Google Chrome, and soon it started to play an indispensable part in my daily workflow. I'm a multitasker, but the computing resource of my laptop is very limited -- Say, if I have a session in which I am working on a homework report, having loads of folders, web pages and editor buffers open and those can fill up gigabytes of RAM easily, then I realize that I will need to compile something really hard-core, or maybe just take a short rest and do some random surfing on the web, certainly I would rather close all those engrossing processes for the time being, hoping that they could continue with all the open tabs I left off.</p>
<p>It's mainly four types of applications that account for so-called &quot;work sessions&quot; for me:</p>
<ul>
<li>Terminal emulator</li>
<li>File manager</li>
<li>Web browser</li>
<li>Text editor</li>
</ul>
<p>Terminals don't take up a lot of memory, so I wouldn't mind leaving them open. Typical browsers, including Chromium and Firefox, do support session resuming (and there are even <a href="https://chrome.google.com/webstore/detail/session-buddy/edacconmaakjimmfgnblocblbcdcpbko">extensions</a> which allow you to save current tabs and recover them at any later time). Any decent text editor (or IDE) may also be configured to remember open tabs / sessions. After all, average file managers fail to meet my basic needs of productivity.</p>
<h2 id="file-managers-the-unremembered-ux">File managers: The unremembered UX</h2>
<p>I'm on GNOME 3, but currently using the <a href="https://github.com/mate-desktop/caja">Caja</a> file manager -- ever since Nautilus 3.6 decided to remove two or three features I found important to me (<a href="https://bugzilla.gnome.org/show_bug.cgi?id=676842">compact mode</a>, <a href="https://bugzilla.gnome.org/show_bug.cgi?id=692852">backspace navigation</a>) and introduced an awkward, smug &quot;search-whatever-shit-as-you-type&quot; feature.</p>
<p>File managers I've tried so far:</p>
<ul>
<li>Nautilus (GNOME). As said, already rendered unusable for me.</li>
<li>Pantheon. Like Nautilus, it doesn't feature a compact mode either.</li>
<li>Nemo (Cinnamon). Nope, segfaults too often.</li>
<li>Caja (MATE). It's OK, just what I'm using right now.
<ul>
<li>Open issue for saving sessions: <a href="https://github.com/mate-desktop/caja/issues/523" class="uri">https://github.com/mate-desktop/caja/issues/523</a></li>
</ul></li>
<li>Dolphin (KDE). OK, unless it's from the foreign land of KDE.
<ul>
<li>Open issue for saving sessions: <a href="https://bugs.kde.org/show_bug.cgi?id=246028" class="uri">https://bugs.kde.org/show_bug.cgi?id=246028</a></li>
</ul></li>
<li>Konqueror (KDE). It's both a web browser and a file manager, and it's the only one I know that can save / restore open tabs. Unfortunately it has only limited file management functionality. (sufficient as a <em>file viewer</em>, though?)</li>
</ul>
<p>Among all above, I settled down with Caja, simply because there was no reasonably good alternative. Still, I'm wishing for something that can save session states for me. After doing a little research, I realized that:</p>
<ol style="list-style-type: decimal">
<li>There is no commonly adopted protocol addressing this issue. <a href="https://wiki.gnome.org/Projects/SessionManagement/SavingState">Not even on GNOME</a>.</li>
<li>There is <a href="https://wiki.gnome.org/Projects/SessionManagement/EggSMClient">EggSMClient</a>, but state saving is implemented on the X (desktop) session level thus only available on the <a href="https://www.x.org/releases/X11R7.7/doc/libSM/xsmp.html">XSMP</a> backend. It works when you logout your desktop session and login, but not when you close the window and restart the application again.</li>
<li>It is ultimately the application itself which must maintain its session states and restore them when required.</li>
</ol>
<h2 id="a-quick-working-patch-for-caja">A quick working patch for Caja</h2>
<p>Let's take the issue into more technical details. On Caja (or other similarly GTK+/GLib-based file managers), one need to implement:</p>
<ul>
<li>On the <code>destroy</code> callback of the main <code>GtkObject</code>, all last remaining session data (e.g., internal states about open tabs, windows) must be saved to disk. (after the main loop ends there's no more chance to get this information back)</li>
<li>On GUI initialization, read last session data (if exist) from disk, and reopen saved tabs as well as windows.</li>
<li>On the event of changing state (e.g., creating or closing tab/window, repositioning tabs), session data are updated respectively and, optionally, saved to disk.</li>
</ul>
<p>With <code>caja_application_get_session_data()</code>, making a quick workaround that enables Caja to save and restore a session is somewhat trivial labor; however, it seems Caja doesn't record the correct (spatial) ordering of tabs in its session data -- so I wouldn't consider this as a satisfying solution to the issue, and I have no intent to send such an incomplete patch to Caja. Nevertheless, it's better than nothing, and, if ordering of tabs really matters, it would be feasible to write a <a href="https://github.com/soimort/dotfiles/blob/b721e42238a90e88c83d1feb20682d0605367b11/Scripts/Open-Folders">wrapper script</a> that manipulates the XML file in <code>$HOME/.config/caja/last-session</code>.</p>
<p>And here goes the patch: (Applied to Caja 1.16.1; definitely UNWARRANTED)</p>
<script src="https://gist.github.com/soimort/73c75266d1610ff0af68b40e7b07d939.js"></script>

      </div>
    </content>
  </entry>

  <entry>
    <title>Boilerplating Pandoc for Academic Writing</title>
    <link href="https://www.soimort.org/notes/161117_pandoc" />
    <id>tag:www.soimort.org,2016:/notes/161117_pandoc</id>
    <updated>2016-11-17</updated>
    <author>
      <name>Mort Yao</name>
      <email>soi@mort.ninja</email>
    </author>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">

<p>For starters, this is how you might want to turn your well-written Markdown file (with common metadata fields like <code>title</code>, <code>author</code> and <code>date</code>) into a properly typeset PDF document:</p>
<pre><code>$ pandoc src.md -o out.pdf</code></pre>
<p>However, Markdown is not TeX. <em>Not even close.</em> Once you need to have some bleeding edge control over the typesetting outcome, or perhaps just a little refinement on its LaTeX templating, you'll soon notice that Pandoc has its quirks and gotchas. I've been utilizing Pandoc in all my serious academic writing (incl. homework reports) for years, ever since I gave up on learning more about the overwhelmingly sophisticated TeX ecosystem and turned to something that &quot;just works&quot;. Pandoc fits my needs well. And when it doesn't, there's almost always a workaround that achieves the same thing neatly. And this is what this write-up is mostly about.</p>
<h2 id="tweaking-default.latex-bad-idea.">Tweaking <code>default.latex</code>? Bad idea.</h2>
<p>You could, of course, modify the default template (<a href="https://github.com/jgm/pandoc-templates/blob/master/default.latex"><code>default.latex</code></a>) provided by Pandoc, as long as you're no stranger to LaTeX. In this way, you can achieve anything you want -- in <em>pure</em> LaTeX.</p>
<pre><code>$ pandoc <span class="do">--template my-default.latex</span> src.md -o out.pdf</code></pre>
<p>There are, however, a few problems with this na√Øve approach:</p>
<ol style="list-style-type: decimal">
<li>If you are tweaking the template just for something you're currently working on, you will end up with some highly document-specific, hardly reusable template. Also this won't give you any good for using Pandoc -- you could just write plain LaTeX anyway.</li>
<li>If Pandoc improves its default template for a newer version, your home-brewed template won't benefit from this (unless you're willing to merge the diffs and resolve any conflicts by hand).</li>
</ol>
<p>I'm conservative about changing the templates. If it's a general issue that needs to be fixed in the default template, sending a pull request to <a href="https://github.com/jgm/pandoc-templates">pandoc-templates</a> might be a better idea. Of course, if there's a certain submission format you have to stick with (given LaTeX templates for conference papers), then you will fall back on your own.</p>
<h2 id="separating-the-formatting-stuff">Separating the formatting stuff</h2>
<p>I wouldn't claim that I know the best practice of using Pandoc, but there's such a common idiom that cannot be overstressed: <em>Separate presentation and content!</em></p>
<p>In the YAML front matter of <code>src.md</code> (the main Markdown file you're writing), put only things that matter to your potential readers:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="ot">---</span>
<span class="fu">title:</span> Boilerplating Pandoc for Academic Writing
<span class="fu">subtitle:</span> or How I Learned to Stop Typesetting and Concentrate on the Math
<span class="fu">author:</span> Mort Yao
<span class="fu">date:</span> 17 November 2016
<span class="fu">abstract:</span> |
  Lorem ipsum dolor sit amet, consectetur adipiscing elit,
  sed do eiusmod tempor incididunt ut labore et dolore magna
  aliqua. Ut enim ad minim veniam, quis nostrud exercitation
  ullamco laboris nisi ut aliquip ex ea commodo consequat.
<span class="ot">---</span></code></pre></div>
<p>And in a separate YAML file (let's call it <code>default.yaml</code>), here goes the formatting stuff:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="ot">---</span>
<span class="fu">geometry:</span> margin=1.5in
<span class="fu">indent:</span> true
<span class="fu">header-includes:</span> |
  \usepackage<span class="kw">{</span>tcolorbox<span class="kw">}</span>
  \newcommand\qed<span class="kw">{</span>\hfill\rule{1em<span class="kw">}{</span>1em<span class="kw">}</span>}
<span class="ot">---</span></code></pre></div>
<p>Above is my personal default, and it's worth a few words to explain:</p>
<ul>
<li><p><code>geometry</code> is where you control the geometric settings of your document. For example, you may narrow down the page margin to <code>margin=1.5in</code>, and this is equivalent to raw LaTeX:</p>
<pre><code>\usepackage[margin=1.5in]{geometry}</code></pre></li>
<li>Set <code>indent</code> to any value other than <code>false</code> if paragraph indentation is desired. (And it is often desired in formal publications.)</li>
<li><code>header-includes</code> is where you define your own macros, configure existing ones, or claim <code>\usepackage</code> in case you want to use a package not enabled by Pandoc (e.g., <a href="https://www.ctan.org/pkg/tcolorbox"><code>tcolorbox</code></a>). Although you might as well define those in other places (e.g., in the content of a Markdown file), <em>don't do that</em>.
<ul>
<li>This decent Q.E.D. tombstone: <code>\newcommand\qed{\hfill\rule{1em}{1em}}</code> is my favorite of all time. It doesn't require the <code>amsthm</code> package.</li>
</ul></li>
</ul>
<p>With a separate <code>default.yaml</code>, now here we are:</p>
<pre><code>$ pandoc <span class="do">default.yaml</span> src.md -o out.pdf</code></pre>
<h2 id="separating-header-includes">Separating <code>header-includes</code></h2>
<p>You might have already noticed that the <code>subtitle</code> field won't display in the produced PDF file. As far as I'm concerned (in Pandoc 1.18), this is the expected behavior. See <a href="http://pandoc.org/MANUAL.html#fn1">here in README</a>:</p>
<blockquote>
<p>To make <code>subtitle</code> work with other LaTeX document classes, you can add the following to <code>header-includes</code>:</p>
<div class="sourceCode"><pre class="sourceCode tex"><code class="sourceCode latex"><span class="fu">\providecommand</span>{<span class="fu">\subtitle</span>}[1]{<span class="co">%</span>
  <span class="bu">\usepackage</span>{<span class="ex">titling</span>}
  <span class="fu">\posttitle</span>{<span class="co">%</span>
    <span class="fu">\par\large</span>#1<span class="kw">\end</span>{<span class="ex">center</span>}}
}</code></pre></div>
</blockquote>
<p>Unfortunately, this won't work (until <a href="https://github.com/jgm/pandoc/issues/2139">Issue #2139</a> is resolved) since Pandoc parses the <code>header-includes</code> metadata field as Markdown, and the bracketed <code>[1]</code> is misinterpreted as literals rather than a part of LaTeX control sequence. So the workaround is: Instead of embedding <code>header-includes</code> as a metadata field in YAML, we should separate it into another file for this dedicated purpose (it's simply raw LaTeX anyway), and include it using <code>--include-in-header/-H</code>:</p>
<pre><code>$ pandoc <span class="do">-H header.tex</span> default.yaml src.md -o out.pdf</code></pre>
<p>Note that you can't have two <code>header-includes</code> for one document. So the <code>header-includes</code> field specified in YAML metadata will be overridden by the content of <code>header.tex</code>.</p>
<h2 id="citing-sources">Citing sources</h2>
<p>While the Markdown syntax for citing is rather easy (<code>[@id]</code>), it takes effort to make things right, especially if you have a certain preferred citation format (APA, MLA, Chicago, IEEE, etc.).</p>
<p>The suggestion is: Use <a href="https://hackage.haskell.org/package/pandoc-citeproc">pandoc-citeproc</a>. Once you have a list of references you're interested in, you need two things to typeset those nicely in your document:</p>
<ul>
<li>A CSL (Citation Style Language) file (<code>.csl</code>), to specify the citation format you want to use.
<ul>
<li>You can preview (and download) many common citation styles in the <a href="https://www.zotero.org/styles">Zotero Style Repository</a>.</li>
</ul></li>
<li>A BibTeX file (<code>.bib</code>), which is a list of all entries you might cite.
<ul>
<li>Citation entries in BibTeX format may be found easily on the Internet, through academic search engines and databases. Concatenate them one by one.</li>
</ul></li>
</ul>
<p>As part of the YAML metadata: (Assume you have <code>ieee.csl</code> and <code>references.bib</code>)</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">csl:</span> ieee.csl
<span class="fu">bibliography:</span> references.bib</code></pre></div>
<p>Using <code>pandoc-citeproc</code> as a filter, generate the document with citations:</p>
<pre><code>$ pandoc <span class="do">--filter pandoc-citeproc</span> -H header.tex default.yaml src.md -o out.pdf</code></pre>
<p>The list of references is appended to the end of the document. It is often desirable to give the references an obvious title (&quot;References&quot;), start from a new page and avoid any further indentation, so the following comes in the end of the Markdown source:</p>
<div class="sourceCode"><pre class="sourceCode tex"><code class="sourceCode latex"><span class="fu">\newpage</span>
<span class="fu">\setlength\parindent</span>{0pt}

# References</code></pre></div>
<h2 id="putting-it-all-together">Putting it all together!</h2>
<p>Basically, we need 5 files in total:</p>
<ul>
<li>For content:
<ul>
<li><code>src.md</code> (Markdown + possibly LaTeX mixed format): Main text.</li>
<li><code>references.bib</code> (BibTeX/BibLaTeX format): List of references.</li>
</ul></li>
<li>For presentation:
<ul>
<li><code>default.yaml</code> (YAML format): Format-related metadata.</li>
<li><code>header.tex</code> (LaTeX format): Content of <code>header-includes</code>; package imports and macro definitions.</li>
<li><code>ieee.csl</code> (CSL XML format): Citation style.</li>
</ul></li>
</ul>
<p>And one command:</p>
<pre><code>$ pandoc --filter pandoc-citeproc -H <span class="do">header.tex</span> <span class="do">default.yaml</span> <span class="do">src.md</span> -o out.pdf</code></pre>
<h2 id="open-question-lightweight-replacement-for-amsthm">Open question: Lightweight replacement for <code>amsthm</code>?</h2>
<p>Pandoc doesn't provide native support for <a href="https://www.ctan.org/pkg/amsthm"><code>amsthm</code></a> (and I wonder if there will ever be). You can still have the same thing in Pandoc Markdown:</p>
<div class="sourceCode"><pre class="sourceCode tex"><code class="sourceCode latex"><span class="fu">\newtheorem</span>{definition}{Definition}

<span class="kw">\begin</span>{<span class="ex">definition</span>}
Man is a rational animal.
<span class="kw">\end</span>{<span class="ex">definition</span>}</code></pre></div>
<p>However, everything in between <code>\begin</code> and <code>\end</code> will be treated as raw LaTeX, and the expressiveness of Markdown is lost there. More importantly, this is purely a LaTeX-specific thing, so there's no way for Pandoc to convert this to HTML or any other format (unless you have a filter that does the trick). Consequently, I tend to write all definitions / theorems (lemmas, claims, corollaries, propositions...) in simple Markdown:</p>
<pre><code>**Definition 1.** *Man is a rational animal.*</code></pre>
<p>It does have some advantages over <code>amsthm</code>:</p>
<ul>
<li>Using <code>amsthm</code>, you cannot see the numbering of each theorem (definition, etc.) in the text editor (well, you can't without a dedicated plugin at least). This is inconvenient when you need to refer to a prior one later. By numbering them explicitly, you can clearly see these ordinals in the Markdown source.</li>
<li>It is perfectly valid Markdown, so it converts to any format as you wish (HTML, for example).</li>
</ul>
<p>This also has some drawbacks compared to using <code>amsthm</code>, though:</p>
<ul>
<li>It doesn't have theorem counters. You need to number things explicitly, manually. (Clearly you can't have implicit numbering and explicit numbering at the same time, so here's the trade-off.)</li>
<li>It doesn't have automatic formatting. That is, you could possibly get the style for a certain entry (plain, definition, remark) wrong.</li>
<li>Semantically, they are not recognized as theorems, just normal text paragraphs. This is problematic if you want to prevent definitions and theorems from being indented, since there's no way for LaTeX to tell them from a normal text.</li>
</ul>
<p>(Probably) The best solution is to write a filter that (conventionally) converts any plain text like <code>Definition 1</code> (and <code>Lemma 2</code>, <code>Theorem 3</code>, etc.) in the beginning of a paragraph to proper Markdown (for HTML target) or corresponding <code>amsthm</code> block (for LaTeX target). Even better, it should be able to do cross-references accordingly (Remember <code>Lemma 10.42</code>? Let's put an anchored link on that!). This is yet to be done, but would be very helpful to someone who does a lot of theorems and proofs thus wants to avoid the kludge of mixing raw LaTeX with semantically evident Markdown.</p>

      </div>
    </content>
  </entry>

  <entry>
    <title>The Decisional Hardness</title>
    <link href="https://www.soimort.org/mst/1" />
    <id>tag:www.soimort.org,2016:/mst/1</id>
    <updated>2016-11-20</updated>
    <author>
      <name>Mort Yao</name>
      <email>soi@mort.ninja</email>
    </author>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">

<p><p style='background-color:yellow'> <strong>(20 Nov 2016) Correction:</strong> P ‚â† NP is not sufficient to imply that one-way functions exist. See <a href="#p-versus-np-problem-and-one-way-functions">P versus NP problem and one-way functions</a>.</p></p>
<hr />
<p><strong>Intro.</strong> Starting from November, I'll summarize my study notes on <a href="https://wiki.soimort.org">wiki</a> into weekly blog posts. I always wanted to keep my study progress on track; I feel that it's hard even to convince myself without visible footprints.</p>
<p>So here we have the first episode. (Hopefully it won't be the last one)</p>
<hr />
<p>Asymptotic notation is an important tool in analyzing the time/space efficiency of algorithms.</p>
<ul>
<li><a href="https://wiki.soimort.org/math/calculus/limit/">Limit</a>
<ul>
<li>Formal definition of limit (the (Œµ, Œ¥)-definition) in calculus. Note that limits involving infinity are closely related to asymptotic analysis. In addition to basic limit rules, L'H√¥pital's rule is also relevant.</li>
</ul></li>
<li><a href="https://wiki.soimort.org/algo/asymptotic-notation/">Asymptotic notation</a>
<ul>
<li>Introduction to the Bachmann‚ÄìLandau notation family (among them are the most widely-used Big O notation and Big Theta notation).</li>
<li>Master theorem is used to find the asymptotic bound for recurrence. This is particularly helpful when analyzing recursive algorithms (e.g., binary search, merge sort, tree traversal).</li>
<li>Based on common orders of asymptotic running time using Big O notation, we can categorize algorithms into various classes of time complexities (among them are P, DLOGTIME, SUBEXP and EXPTIME). Note that we have not formally defined the word &quot;algorithm&quot; and &quot;complexity class&quot; yet.</li>
</ul></li>
</ul>
<p>For decision problems, we now formally define the time complexity classes P and NP, and propose the hardness of NP-complete problems, which plays an indispensable role in the study of algorithm design and modern cryptography.</p>
<ul>
<li><a href="https://wiki.soimort.org/comp/language/">Formal language</a>
<ul>
<li>Formal definition of language. We will revisit this when studying formal grammars like the context-free grammar and parsing techniques for compilers. For now, it suffices to know that binary string is a common encoding for all kinds of problems (especially, decision problems).</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/decidability/">Decidability</a>
<ul>
<li>Among all abstract problems, we are mostly interested in decision problems.</li>
<li>The decidability of a language depends on whether there exists an algorithm that decides it.</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/reducibility/">Reducibility</a>
<ul>
<li>Polynomial-time reduction is a commonly used technique that maps one language to another.</li>
<li>What is a hard language for a complexity class; what is a complete language for a complexity class.</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/complexity/time/">Time complexity</a>
<ul>
<li>Encodings of concrete problems matter. Normally we would choose a &quot;standard encoding&quot; for our language of interest.</li>
<li>Polynomial-time algorithms are considered to be efficient and languages which have polynomial-time algorithms that decide them are considered tractable.</li>
<li>P is the time complexity class of all problems that are polynomial-time solvable.</li>
<li>NP is the time complexity class of all problems that are polynomial-time verifiable.</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/complexity/time/npc/">NP-completeness</a>
<ul>
<li>The set of languages that are complete for the complexity class NP, that is, the &quot;hardest problems&quot; in NP.</li>
<li>NP-complete problems are central in answering the open question whether P = NP.</li>
<li>We (informally) show that every NP problem is polynomial-time reducible to CIRCUIT-SAT, and that CIRCUIT-SAT is NP-complete.</li>
<li>There are other problems (SAT, 3-CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP, SUBSET-SUM) polynomial-time reducible from one to another, thus they are also shown to be NP-complete.</li>
</ul></li>
</ul>
<p><strong>Computational hardness assumption P ‚â† NP.</strong> Although it is still an open proposition, many believe that P ‚â† NP. Notably, if P ‚â† NP holds true,</p>
<ol style="list-style-type: decimal">
<li>If a decision problem is polynomial-time unsolvable in general case, we should strive to find approximations or randomized algorithms; exact algorithms cannot be run in worst-case polynomial time thus may not be efficient. This applies to optimization problems too.</li>
<li><del>
One-way functions exist, which implies that pseudorandom generators and functions exist. Consequently, many cryptographic constructions (private-key encryption, MACs, etc.) are provably computationally secure.
</del></li>
</ol>
<p><p style='background-color:yellow'> (I stand corrected: There is no such a known proof showing that P ‚â† NP implies the existence of one-way functions. However, reversely, the existence of one-way functions implies that P ‚â† NP. There is an informal argument given by Peter Shor on StackExchange<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, rephrased in the section <a href="#p-versus-np-problem-and-one-way-functions">P versus NP problem and one-way functions</a>.)</p></p>
<p>Later we will cover the notion of security in cryptography, so there is a refresher of basic probability: (Probability is also considerably used in analyzing the behaviors of non-deterministic algorithms, hash functions, etc.)</p>
<ul>
<li><a href="https://wiki.soimort.org/math/probability/">Probability</a>
<ul>
<li>An intuitive introduction to basic probability theory based on Kolmogorov's axioms, including the union bound (Boole's inequality) and its generalized form Bonferroni inequalities, the conditional probability and Bayes' theorem. We will revisit the notion of probability space when coming to measure theory.</li>
</ul></li>
</ul>
<p>Plan for next week:</p>
<ul>
<li><strong>(Algorithms)</strong> More involved NP-complete problems. Exact algorithms. Approximation algorithms. Probabilistic algorithms.</li>
<li><strong>(Cryptography)</strong> Information-theoretic/computational security (semantic security, IND, IND-CPA, IND-CCA). Private-key encryption. Message authentication codes. Hash functions. Theoretical constructions (one-way functions, pseudorandomness). Practical constructions (Feistel network, substitution-permutation network, DES, AES).</li>
</ul>
<h2 id="p-versus-np-problem-and-one-way-functions">P versus NP problem and one-way functions</h2>
<p>Consider the following map: <br /><span class="math display"><em>f</em>‚ÄÑ:‚ÄÑ(<em>x</em>,‚ÄÜ<em>r</em>)‚Üí<em>s</em></span><br /> where <span class="math inline"><em>x</em></span> is an arbitrary bit string, <span class="math inline"><em>r</em></span> is a string of random bits, and <span class="math inline"><em>s</em></span> is an instance of a <span class="math inline"><em>k</em></span>-SAT problem having <span class="math inline"><em>x</em></span> as a planted solution, while the randomness of <span class="math inline"><em>r</em></span> determines uniquely which <span class="math inline"><em>k</em></span>-SAT problem to choose.</p>
<p>If we can invert the above function <span class="math inline"><em>f</em></span> (in polynomial time), we must already have solved the corresponding <span class="math inline"><em>k</em></span>-SAT problem <span class="math inline"><em>s</em></span> with a planted solution <span class="math inline"><em>x</em></span>. <span class="math inline"><em>k</em></span>-SAT problems are known to be NP-complete, and inverting such a function would be as hard as solving a <span class="math inline"><em>k</em></span>-SAT problem with a planted solution, that is, inverting <span class="math inline"><em>f</em></span> <em>at one point</em> can be hard. Clearly, should we have a one-way function, then inverting it is guaranteed to be no easier than inverting <span class="math inline"><em>f</em></span>.</p>
<p>So what does it mean if P ‚â† NP? We know that <span class="math inline"><em>k</em></span>-SAT problem is hard to solve in its <em>worst case</em>, so function <span class="math inline"><em>f</em></span> can be made as hard to invert as solving a <span class="math inline"><em>k</em></span>-SAT problem in its <em>worst case</em>. However, we don't know whether it's possible to have a class <span class="math inline">ùíÆ</span> of <span class="math inline"><em>k</em></span>-SAT problems with planted solutions that are as hard as general-case <span class="math inline"><em>k</em></span>-SAT problems. If such a class <span class="math inline">ùíÆ</span> exists, then given any <span class="math inline"><em>s</em>‚ÄÑ‚àà‚ÄÑùíÆ</span>, no probabilistic polynomial-time algorithm is able to get <span class="math inline"><em>x</em></span> with a non-negligible probability, so we can conclude that <span class="math inline"><em>f</em></span> is indeed a one-way function. <a href="#ref-selman1992survey"><span class="citation">(<span class="citeproc-not-found" data-reference-id="selman1992survey"><strong>???</strong></span>)</span></a></p>
<p><strong>Problem 1.1.</strong> Does there exist a class <span class="math inline">ùíÆ</span> of <span class="math inline"><em>k</em></span>-SAT problems with planted solutions, such that every <span class="math inline"><em>L</em>‚ÄÑ‚àà‚ÄÑùíÆ</span> is NP-hard?</p>
<p><strong>Conjecture 1.2.</strong> <em>If <span class="math inline"><em>P</em>‚ÄÑ‚â†‚ÄÑ<em>N</em><em>P</em></span>, then one-way functions exist.</em></p>
<p>On the other hand, assume that <span class="math inline"><em>f</em></span> is a one-way function, so that one-way functions do exist, then this implies that <span class="math inline"><em>k</em></span>-SAT problem is hard to solve (in its worse case) by a polynomial-time algorithm, thus we have P ‚â† NP. By modus tollens, if P = NP, then no one-way function exists. <a href="#ref-abadi1990generating"><span class="citation">(<span class="citeproc-not-found" data-reference-id="abadi1990generating"><strong>???</strong></span>)</span></a></p>
<p><strong>Theorem 1.3.</strong> <em>If one-way functions exist, then <span class="math inline"><em>P</em>‚ÄÑ‚â†‚ÄÑ<em>N</em><em>P</em></span>.</em></p>
<p><em>Proof.</em> <em>(Sketch)</em> Let <span class="math inline"><em>f</em>‚ÄÑ:‚ÄÑ{0,‚ÄÜ1}<sup>*</sup>‚ÄÑ‚Üí‚ÄÑ{0,‚ÄÜ1}<sup>*</sup></span> be a one-way function. There is a polynomial-time algorithm <span class="math inline"><em>M</em><sub><em>f</em></sub></span> that computes <span class="math inline"><em>y</em>‚ÄÑ=‚ÄÑ<em>f</em>(<em>x</em>)</span> for all <span class="math inline"><em>x</em></span>, thus, there exists a polynomial-time computable circuit that outputs <span class="math inline"><em>y</em>‚ÄÑ=‚ÄÑ<em>f</em>(<em>x</em>)</span> for all <span class="math inline"><em>x</em></span>.</p>
<p>Since <span class="math inline"><em>f</em></span> is a one-way function, that is, for every probabilistic polynomial-time algorithm <span class="math inline">ùíú</span>, there is a negligible function <span class="math inline">negl</span> such that <span class="math inline">Pr[Invert<sub>ùíú,‚ÄÜ<em>f</em></sub>(<em>n</em>)=1]‚â§negl(<em>n</em>)</span>, so we know that no <span class="math inline">ùíú</span> can fully compute <span class="math inline"><em>f</em><sup>‚àí1</sup>(<em>x</em>)</span> for any given <span class="math inline"><em>x</em></span>. <span class="math inline">ùíú</span> fully computes <span class="math inline"><em>f</em><sup>‚àí1</sup></span> if and only if it solves the corresponding <code>CIRCUIT-SAT</code> problems of the circuit in all cases. Thus, there must exist some <code>CIRCUIT-SAT</code> problems that cannot be decided by a polynomial-time algorithm, therefore, <span class="math inline"><em>P</em>‚ÄÑ‚â†‚ÄÑ<em>N</em><em>P</em></span>. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p><em>Remark 1.4.</em> If one can come up with a construction of the one-way function or a proof that such functions exist, then it holds true that <span class="math inline"><em>P</em>‚ÄÑ‚â†‚ÄÑ<em>N</em><em>P</em></span>.</p>
<h2 id="references-and-further-reading">References and Further Reading</h2>
<p><strong>Books:</strong></p>
<p>T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, <em>Introduction to Algorithms</em>, 3rd ed.</p>
<p>M. Sipser, <em>Introduction to the Theory of Computation</em>, 3rd ed.</p>
<p>J. Katz and Y. Lindell, <em>Introduction to Modern Cryptography</em>, 2nd ed.</p>
<p><strong>Papers:</strong></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://cstheory.stackexchange.com/a/8843/21291" class="uri">http://cstheory.stackexchange.com/a/8843/21291</a><a href="#fnref1">‚Ü©</a></p></li>
</ol>
</div>

      </div>
    </content>
  </entry>

</feed>
